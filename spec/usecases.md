# ユースケース

## 概要

このドキュメントでは、各シナリオを実現するために必要なユースケース（アプリケーションサービス）を定義する。

## 設計方針

- **ユースケースは独立した単位**として設計し、ユースケース間の依存を避ける
- **Webhookイベントの処理**はプレゼンテーション層（ルーター/コントローラー）の責務とする
- **メッセージの返信**はポート/アダプターとして扱い、各ユースケースから利用する

## 1. ドキュメント同期ユースケース

### UC-SYNC-001: ドキュメントを同期する

- **概要**: 外部APIからドキュメントを取得し、インデックスを更新する
- **アクター**: ユーザー（syncコマンド経由）
- **事前条件**: APIエンドポイントが設定されている
- **事後条件**: インデックスが最新のドキュメントで更新される
- **主要フロー**:
    1. 同期開始メッセージを返信する
    2. ドキュメント一覧を取得する（ページネーション対応）
    3. 各ドキュメントの内容を取得する
    4. ドキュメントをパースする
    5. インデックスを更新する
    6. 同期完了メッセージを返信する
- **代替フロー**:
    - API接続エラー: エラーメッセージを返信する
    - 一部ドキュメント取得失敗: 取得できたドキュメントのみで処理を継続し、部分的成功メッセージを返信する
    - パースエラー: 該当ドキュメントをスキップし、エラーをログに記録する
    - インデックス更新エラー: エラーメッセージを返信する
- **エラーハンドリング詳細**:
    - **ドキュメント一覧取得失敗時**: 処理を中断し、エラーメッセージを返信。インデックスは更新しない（既存のインデックスを維持）
    - **全ドキュメント取得失敗時**: 処理を中断し、エラーメッセージを返信。インデックスは更新しない
    - **一部ドキュメント取得/パース失敗時**: 成功したドキュメントのみでインデックスを再構築。部分的成功メッセージを返信
    - **インデックス構築失敗時**: エラーメッセージを返信。インデックスは不完全な状態になる可能性があるため、再度syncを促す
      - **不完全な状態の例**: ドキュメントは保存されたがベクトルエントリが作成されていない、一部のドキュメントのみインデックス化されている等
      - **状態確認方法**: `status`コマンドでドキュメント数とエントリ数を確認し、不整合がないかチェックする
      - **復旧手順**: 再度`sync`コマンドを実行することで、全削除→全挿入が行われ、一貫した状態に復旧する
    - **Push通知失敗時**: エラーをログに記録し、処理を継続（ユーザーへの通知は失敗するが、インデックス更新は完了）
- **リトライポリシー**:
    - 現時点ではユースケースレベルでのリトライは行わない
    - 個別のAPI呼び出し（ドキュメント取得、LINE API）はアダプター層でリトライを実装
    - ユーザーが手動で再度syncコマンドを実行することでリトライ相当の処理が可能
- **関連シナリオ**: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 3.1, 3.2, 3.3, 3.4, 3.5
- **関連要件**: FR-SYNC-001〜007, FR-PARSE-001〜005, FR-INDEX-001, FR-INDEX-002, NFR-ERR-001, NFR-ERR-002, NFR-REL-001
- **トランザクション境界**:
    - フェーズ1: ドキュメント取得・パース（トランザクション外）
      - DocumentListFetcher、DocumentContentFetcher、DocumentParserの呼び出し
      - 外部APIへのアクセスを含むため、トランザクション外で実行
    - フェーズ2: ドキュメント保存+インデックス再構築（単一トランザクション）
      - 以下の順序で実行する:
        1. DocumentRepository.deleteAll() - 既存ドキュメントを全削除（ON DELETE CASCADEにより関連するベクトルエントリも自動削除）
        2. DocumentRepository.saveMany() - 新規ドキュメントを全挿入
        3. VectorStore.add() - 新規のベクトルエントリを全挿入
      - エラー発生時はロールバックされ、既存のインデックスが維持される
    - **復旧方法**: フェーズ2でエラーが発生した場合、再度syncコマンドを実行することで復旧可能
- **バックグラウンド実行方針**:
    - 初期実装: Webhookハンドラで即座にHTTP 200を返却後、`Promise`で非同期実行
    - Webhookタイムアウト（30秒）への対応として、処理開始前に返信（Reply）を完了させる
    - 処理完了後のPush通知は別途実行され、失敗してもインデックス更新は完了する
    - 将来のスケーラブル実装: ジョブキュー（BullMQ等）への移行を検討可能
- **古いドキュメント削除方針**:
    - 方式: 全削除→全挿入（シンプルだが非効率）
    - 理由: 初期実装のシンプルさを優先。外部APIから削除されたドキュメントも確実に削除される
    - 実装: VectorStore.clear()で全エントリを削除後、新規エントリをVectorStore.add()で追加
    - 将来の最適化: 差分更新方式（変更されたドキュメントのみ更新）への移行を検討可能

## 2. 質問応答ユースケース

### UC-QA-001: 質問に回答する

- **概要**: ユーザーの質問に対してRAGを使用して回答を生成する
- **アクター**: ユーザー（質問メッセージ経由）
- **事前条件**: なし
- **事後条件**: ユーザーに回答が返信される
- **主要フロー**:
    1. インデックスの存在を確認する
    2. RAGでインデックスを検索し、関連ドキュメントを取得する
    3. 取得したドキュメントと質問をもとにLLMで回答を生成する
    4. （設定が有効な場合）回答を永続化する
    5. 回答を返信する
- **代替フロー**:
    - インデックス未構築: 同期を促すメッセージを返信する
    - 関連ドキュメントなし: 適切なメッセージを返信する
    - RAG検索エラー: エラーメッセージを返信する
    - LLM回答生成エラー: エラーメッセージを返信する
    - 回答永続化エラー: エラーをログに記録し、回答の返信は継続する（永続化は非クリティカル）
- **回答永続化の設定**:
    - 設定の`answer.persistEnabled`で有効/無効を制御（デフォルト: false）
    - 有効時は全ての回答をanswersテーブルに保存
    - 用途: 回答履歴の分析、品質改善のためのデータ収集
- **関連シナリオ**: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
- **関連要件**: FR-QA-001〜007, FR-INDEX-003, NFR-ERR-003, NFR-ERR-004

## 3. インデックス状態確認ユースケース

### UC-STATUS-001: インデックス状態を確認する

- **概要**: インデックスの現在の状態（ドキュメント数、エントリ数、最終更新日時等）を確認する
- **アクター**: ユーザー（statusコマンド経由）
- **事前条件**: なし
- **事後条件**: ユーザーにインデックスの状態が返信される
- **主要フロー**:
    1. インデックスのステータス情報を取得する
    2. ドキュメント数、エントリ数、最終更新日時を含むステータスメッセージを生成する
    3. ステータスメッセージを返信する
- **代替フロー**:
    - インデックス未構築: インデックスが未構築であることを通知し、syncコマンドを促すメッセージを返信する
    - ステータス取得エラー: エラーメッセージを返信する
- **関連シナリオ**: 1.7, 1.8
- **関連要件**: FR-STATUS-001, FR-STATUS-002, FR-STATUS-003, FR-INDEX-003, NFR-ERR-001

## 4. ユースケース関連図

```
┌─────────────────────────────────────────────────────────────┐
│                      LINE Messaging API                       │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  プレゼンテーション層    │
                 │  (Webhook Handler)     │
                 │  - 署名検証            │
                 │  - イベント解析         │
                 │  - コマンド/質問判定    │
                 └────────────┬───────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│  UC-SYNC-001     │ │  UC-QA-001       │ │  UC-STATUS-001   │
│  ドキュメントを   │ │  質問に回答する   │ │  インデックス状態 │
│  同期する        │ │                  │ │  を確認する       │
└────────┬─────────┘ └────────┬─────────┘ └────────┬─────────┘
         │                    │                    │
         │    ┌───────────────┴────────────────┐   │
         └───►│        MessageSender           │◄──┘
              │       (メッセージ返信)          │
              └────────────────────────────────┘
```

## 5. ユースケースと使用ドメイン

各ユースケースは複数のドメインを横断してオーケストレーションを行う。

| ユースケース | 使用ドメイン |
|------------|------------|
| UC-SYNC-001 | Document, VectorIndex, Message |
| UC-QA-001 | VectorIndex, Answer, Message |
| UC-STATUS-001 | Document, VectorIndex, Message |

## 6. ユースケースが使用するポート

### UC-SYNC-001: ドキュメントを同期する

- `DocumentListFetcher`: ドキュメント一覧取得
- `DocumentContentFetcher`: ドキュメント内容取得
- `DocumentParser`: ドキュメントのパース
- `DocumentRepository`: ドキュメントの永続化
- `TextSplitter`: テキストのチャンク分割
- `EmbeddingGenerator`: 埋め込みベクトル生成
- `VectorStore`: インデックス更新
- `MessageSender`: メッセージ返信

### UC-QA-001: 質問に回答する

- `VectorStore`: インデックス存在確認、類似検索
- `EmbeddingGenerator`: クエリの埋め込み生成
- `AnswerGenerator`: 回答生成
- `AnswerRepository`: 回答の永続化（オプショナル）
- `MessageSender`: メッセージ返信

### UC-STATUS-001: インデックス状態を確認する

- `DocumentRepository`: ドキュメント数取得
- `VectorStore`: インデックスステータス取得
- `MessageSender`: メッセージ返信

## 7. プレゼンテーション層の責務

以下はユースケースではなく、プレゼンテーション層で処理する。単一責任の原則に従い、責務ごとに分離する。

### 責務の分離

#### ミドルウェア

- **署名検証**: LINE Webhookリクエストの署名を検証（FR-LINE-002, NFR-SEC-001）
  - 実装: `src/api/middlewares/lineSignatureVerifier.ts`
  - 不正な署名の場合は401を返却

#### イベントパーサー

専用のパーサークラスでWebhookイベントを解析する。

- **WebhookEventParser**: Webhookイベントの解析・変換
  - 実装: `src/api/parsers/webhookEventParser.ts`
  - メッセージイベントの抽出
  - イベントタイプの判定

- **CommandParser**: コマンド識別
  - 実装: `src/api/parsers/commandParser.ts`
  - syncコマンドの識別
  - statusコマンドの識別
  - 質問メッセージの識別

#### ルーター/コントローラー

ルーターはパーサーの結果を受け取り、適切なユースケースを呼び出すのみ。

- **Webhookルーター**: ユースケース呼び出し
  - 実装: `src/api/routes/webhook.ts`
  - パーサー結果に基づくユースケース振り分け
  - HTTPレスポンスの返却

### 処理フロー

```
┌─────────────────┐
│ HTTPリクエスト    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 署名検証         │ ← ミドルウェア
│ (Middleware)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ イベント解析      │ ← パーサー
│ (EventParser)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ コマンド判定      │ ← パーサー
│ (CommandParser) │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ ユースケース呼び出し│ ← ルーター
│ (Router)        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ HTTPレスポンス    │
└─────────────────┘
```

### 設計意図

- **単一責任の原則**: 各クラスは1つの責務のみを持つ
- **テスト容易性**: パーサーを分離することで単体テストが容易になる
- **再利用性**: パーサーロジックを他のエンドポイントでも再利用可能
