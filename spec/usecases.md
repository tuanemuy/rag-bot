# ユースケース

## 概要

このドキュメントでは、各シナリオを実現するために必要なユースケース（アプリケーションサービス）を定義する。

## 設計方針

- **ユースケースは独立した単位**として設計し、ユースケース間の依存を避ける
- **Webhookイベントの処理**はプレゼンテーション層（ルーター/コントローラー）の責務とする
- **メッセージの返信**はポート/アダプターとして扱い、各ユースケースから利用する

## 1. ドキュメント同期ユースケース

### UC-SYNC-001: ドキュメントを同期する

- **概要**: 外部APIからドキュメントを取得し、インデックスを更新する
- **アクター**: ユーザー（syncコマンド経由）
- **事前条件**: APIエンドポイントが設定されている
- **事後条件**: インデックスが最新のドキュメントで更新される
- **入力**:
    - `eventSource: EventSource` - Webhookイベントの送信元情報（Push通知の送信先として使用）
    - `replyToken: ReplyToken` - 同期開始メッセージの返信用トークン
- **主要フロー**:
    1. 同期開始メッセージを返信する（Reply API使用、replyTokenを消費）
    2. DocumentSourceからすべてのドキュメントを順次取得する
    3. インデックスを更新する
    4. EventSourceからgetEventSourceDestinationで送信先を取得し、同期完了メッセージをPush通知する
- **代替フロー**:
    - API接続エラー: エラーメッセージを返信する
    - 一部ドキュメント取得失敗: 取得できたドキュメントのみで処理を継続し、部分的成功メッセージを返信する
    - パースエラー: 該当ドキュメントをスキップし、エラーをログに記録する
    - インデックス更新エラー: エラーメッセージを返信する
- **エラーハンドリング詳細**:
    - **全ドキュメント取得失敗時**: 処理を中断し、エラーメッセージを返信。インデックスは更新しない（既存のインデックスを維持）
    - **一部ドキュメント取得/パース失敗時**: 成功したドキュメントのみでインデックスを再構築。部分的成功メッセージを返信
    - **インデックス構築失敗時**: エラーメッセージを返信。インデックスは不完全な状態になる可能性があるため、再度syncを促す
      - **不完全な状態の例**: ドキュメントは保存されたがベクトルエントリが作成されていない、一部のドキュメントのみインデックス化されている等
      - **状態確認方法**: `status`コマンドでドキュメント数とエントリ数を確認し、不整合がないかチェックする
      - **復旧手順**: 再度`sync`コマンドを実行することで、全削除→全挿入が行われ、一貫した状態に復旧する
    - **Push通知失敗時**: エラーをログに記録し、処理を継続（ユーザーへの通知は失敗するが、インデックス更新は完了）
- **リトライポリシー**:
    - 現時点ではユースケースレベルでのリトライは行わない
    - 個別のAPI呼び出し（ドキュメント取得、LINE API）はアダプター層でリトライを実装
    - ユーザーが手動で再度syncコマンドを実行することでリトライ相当の処理が可能
- **関連シナリオ**: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 3.1, 3.2, 3.3, 3.4, 3.5
- **関連要件**: FR-SYNC-001〜007, FR-PARSE-001〜005, FR-INDEX-001, FR-INDEX-002, NFR-ERR-001, NFR-ERR-002, NFR-REL-001
- **トランザクション境界**:
    - フェーズ1: ドキュメント取得（トランザクション外）
      - DocumentSourceの呼び出し
      - 外部APIへのアクセスを含むため、トランザクション外で実行
    - フェーズ2: ドキュメント保存（単一トランザクション）
      - 以下の順序で実行する:
        1. DocumentRepository.deleteAll() - 既存ドキュメントを全削除
        2. DocumentRepository.saveMany() - 新規ドキュメントを全挿入
      - エラー発生時はロールバックされ、既存のドキュメントが維持される
    - フェーズ3: インデックス構築（別トランザクション/独立実行）
      - IndexBuilder.buildIndex() - 新規のベクトルエントリを生成・挿入
      - LlamaIndexが内部でDBコネクションを管理するため、フェーズ2とは別に実行
      - 内部でベクトルストアのクリア→再構築を実施
    - **注意**: フェーズ2とフェーズ3は別トランザクションのため、フェーズ2成功後にフェーズ3が失敗するとドキュメントとインデックスの不整合が発生する可能性がある
    - **復旧方法**: エラー発生時は再度syncコマンドを実行することで復旧可能（全再構築方式のため、一貫した状態に戻る）
- **バックグラウンド実行方針**:
    - 初期実装: Webhookハンドラで即座にHTTP 200を返却後、`Promise`で非同期実行
    - Webhookタイムアウト（30秒）への対応として、処理開始前に返信（Reply）を完了させる
    - 処理完了後のPush通知は別途実行され、失敗してもインデックス更新は完了する
    - 将来のスケーラブル実装: ジョブキュー（BullMQ等）への移行を検討可能
- **古いドキュメント削除方針**:
    - 方式: 全削除→全挿入（シンプルだが非効率）
    - 理由: 初期実装のシンプルさを優先。外部APIから削除されたドキュメントも確実に削除される
    - 実装: IndexBuilder.buildIndex()で既存インデックスをクリアし、新規エントリを生成・挿入
    - 将来の最適化: 差分更新方式（変更されたドキュメントのみ更新）への移行を検討可能

## 2. 質問応答ユースケース

### UC-QA-001: 質問に回答する

- **概要**: ユーザーの質問に対してRAGを使用して回答を生成する
- **アクター**: ユーザー（質問メッセージ経由）
- **事前条件**: なし
- **事後条件**: ユーザーに回答が返信される
- **主要フロー**:
    1. インデックスの存在を確認する
    2. RAGでインデックスを検索し、関連ドキュメントを取得する
    3. 取得したドキュメントと質問をもとにLLMで回答を生成する
    4. 回答を返信する
- **代替フロー**:
    - インデックス未構築: 同期を促すメッセージを返信する
    - 関連ドキュメントなし: 適切なメッセージを返信する
    - RAG検索エラー: エラーメッセージを返信する
    - LLM回答生成エラー: エラーメッセージを返信する
- **関連シナリオ**: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
- **関連要件**: FR-QA-001〜007, FR-INDEX-003, NFR-ERR-003, NFR-ERR-004

## 3. インデックス状態確認ユースケース

### UC-STATUS-001: インデックス状態を確認する

- **概要**: インデックスの現在の状態（ドキュメント数、エントリ数、最終更新日時等）を確認する
- **アクター**: ユーザー（statusコマンド経由）
- **事前条件**: なし
- **事後条件**: ユーザーにインデックスの状態が返信される
- **主要フロー**:
    1. インデックスのステータス情報を取得する
    2. ドキュメント数、エントリ数、最終更新日時を含むステータスメッセージを生成する
    3. ステータスメッセージを返信する
- **代替フロー**:
    - インデックス未構築: インデックスが未構築であることを通知し、syncコマンドを促すメッセージを返信する
    - ステータス取得エラー: エラーメッセージを返信する
- **関連シナリオ**: 1.7, 1.8
- **関連要件**: FR-STATUS-001, FR-STATUS-002, FR-STATUS-003, FR-INDEX-003, NFR-ERR-001

## 4. ユースケース関連図

```
┌─────────────────────────────────────────────────────────────┐
│                      LINE Messaging API                       │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  プレゼンテーション層    │
                 │  (Webhook Handler)     │
                 │  - 署名検証            │
                 │  - イベント解析         │
                 │  - コマンド/質問判定    │
                 └────────────┬───────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│  UC-SYNC-001     │ │  UC-QA-001       │ │  UC-STATUS-001   │
│  ドキュメントを   │ │  質問に回答する   │ │  インデックス状態 │
│  同期する        │ │                  │ │  を確認する       │
└────────┬─────────┘ └────────┬─────────┘ └────────┬─────────┘
         │                    │                    │
         │    ┌───────────────┴────────────────┐   │
         └───►│        MessageSender           │◄──┘
              │       (メッセージ返信)          │
              └────────────────────────────────┘
```

## 5. ユースケースと使用ドメイン

各ユースケースは複数のドメインを横断してオーケストレーションを行う。

| ユースケース | 使用ドメイン |
|------------|------------|
| UC-SYNC-001 | Document, VectorIndex, Message |
| UC-QA-001 | VectorIndex, Message |
| UC-STATUS-001 | Document, VectorIndex, Message |

## 6. ユースケースが使用するポート

### UC-SYNC-001: ドキュメントを同期する

- `DocumentSource`: ドキュメントの順次取得（取得・パースを内包）
- `DocumentRepository`: ドキュメントの永続化
- `IndexBuilder`: インデックス構築（チャンク分割、埋め込み生成、ベクトルストア操作を内包）
- `MessageSender`: メッセージ返信

### UC-QA-001: 質問に回答する

- `QueryEngine`: インデックス検索と回答生成（埋め込み生成、類似検索、LLM回答生成を内包）
- `MessageSender`: メッセージ返信

### UC-STATUS-001: インデックス状態を確認する

- `DocumentRepository`: ドキュメント数取得
- `IndexBuilder`: インデックスステータス取得
- `MessageSender`: メッセージ返信

## 7. プレゼンテーション層の責務

以下はユースケースではなく、プレゼンテーション層で処理する。単一責任の原則に従い、責務ごとに分離する。

### 責務の分離

#### ミドルウェア

- **署名検証**: LINE Webhookリクエストの署名を検証（FR-LINE-002, NFR-SEC-001）
  - 実装: `src/api/middlewares/lineSignatureVerifier.ts`
  - 不正な署名の場合は401を返却

#### イベントパーサー

専用のパーサークラスでWebhookイベントを解析する。

- **WebhookEventParser**: Webhookイベントの解析・変換
  - 実装: `src/api/parsers/webhookEventParser.ts`
  - メッセージイベントの抽出
  - イベントタイプの判定

- **CommandParser**: コマンド識別
  - 実装: `src/api/parsers/commandParser.ts`
  - syncコマンドの識別
  - statusコマンドの識別
  - 質問メッセージの識別

#### ルーター/コントローラー

ルーターはパーサーの結果を受け取り、適切なユースケースを呼び出すのみ。

- **Webhookルーター**: ユースケース呼び出し
  - 実装: `src/api/routes/webhook.ts`
  - パーサー結果に基づくユースケース振り分け
  - HTTPレスポンスの返却

### 処理フロー

```
┌─────────────────┐
│ HTTPリクエスト    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 署名検証         │ ← ミドルウェア
│ (Middleware)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ イベント解析      │ ← パーサー
│ (EventParser)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ コマンド判定      │ ← パーサー
│ (CommandParser) │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ ユースケース呼び出し│ ← ルーター
│ (Router)        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ HTTPレスポンス    │
└─────────────────┘
```

### 設計意図

- **単一責任の原則**: 各クラスは1つの責務のみを持つ
- **テスト容易性**: パーサーを分離することで単体テストが容易になる
- **再利用性**: パーサーロジックを他のエンドポイントでも再利用可能
