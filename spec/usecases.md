# ユースケース

## 概要

このドキュメントでは、各シナリオを実現するために必要なユースケース（アプリケーションサービス）を定義する。

## 設計方針

- **ユースケースは独立した単位**として設計し、ユースケース間の依存を避ける
- **Webhookイベントの処理**はプレゼンテーション層（ルーター/コントローラー）の責務とする
- **ユーザーへの通知**はUserNotifierポートを通じて行い、メッセージ文言はアダプター層で管理する

## 1. ドキュメント同期ユースケース

### UC-SYNC-001: ドキュメントを同期する

- **概要**: 外部APIからドキュメントを取得し、インデックスを更新する
- **アクター**: ユーザー（syncコマンド経由）
- **事前条件**: APIエンドポイントが設定されている
- **事後条件**: インデックスが最新のドキュメントで更新される
- **入力**:
    - `eventSource: EventSource` - Webhookイベントの送信元情報（Push通知の送信先として使用）
    - `replyToken: ReplyToken` - 同期開始メッセージの返信用トークン
- **主要フロー**:
    1. UserNotifier.notifySyncStarting()で同期開始を通知する（Reply API使用、replyTokenを消費）
    2. インデックスをクリアする
    3. DocumentSourceからドキュメントをバッチ単位で取得し、インデックスに追加する
    4. UserNotifier.notifySyncCompleted()で同期完了を通知する（Push API使用）
- **代替フロー**:
    - API接続エラー: UserNotifier.notifySyncError()でエラーを通知する
    - 一部ドキュメント取得失敗: 取得できたドキュメントのみで処理を継続し、notifySyncCompleted()で部分的成功を通知する
    - パースエラー: 該当ドキュメントをスキップし、エラーをログに記録する
    - インデックス更新エラー: UserNotifier.notifySyncError()でエラーを通知する
    - ドキュメントなし: UserNotifier.notifyNoDocumentsFound()で通知する
- **エラーハンドリング詳細**:
    - **全ドキュメント取得失敗時**: 処理を中断し、エラーメッセージを返信。インデックスは更新しない（既存のインデックスを維持）
    - **一部ドキュメント取得/パース失敗時**: 成功したドキュメントのみでインデックスを再構築。部分的成功メッセージを返信
    - **インデックス構築失敗時**: エラーメッセージを返信。インデックスは不完全な状態になる可能性があるため、再度syncを促す
      - **不完全な状態の例**: ドキュメントは保存されたがベクトルエントリが作成されていない、一部のドキュメントのみインデックス化されている等
      - **状態確認方法**: `status`コマンドでドキュメント数とエントリ数を確認し、不整合がないかチェックする
      - **復旧手順**: 再度`sync`コマンドを実行することで、全削除→全挿入が行われ、一貫した状態に復旧する
    - **Push通知失敗時**: エラーをログに記録し、処理を継続（ユーザーへの通知は失敗するが、インデックス更新は完了）
- **リトライポリシー**:
    - 現時点ではユースケースレベルでのリトライは行わない
    - 個別のAPI呼び出し（ドキュメント取得、LINE API）はアダプター層でリトライを実装
    - ユーザーが手動で再度syncコマンドを実行することでリトライ相当の処理が可能
- **関連シナリオ**: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 3.1, 3.2, 3.3, 3.4, 3.5
- **関連要件**: FR-SYNC-001〜007, FR-PARSE-001〜005, FR-INDEX-001, FR-INDEX-002, NFR-ERR-001, NFR-ERR-002, NFR-REL-001, NFR-REL-002, NFR-REL-003
- **トランザクション境界**:
    - フェーズ1: インデックスクリア
      - IndexBuilder.clearIndex() - 既存のベクトルエントリを全削除
      - LlamaIndexが内部でDBコネクションを管理
    - フェーズ2: バッチ処理（繰り返し）
      - DocumentSourceからバッチ単位でドキュメントを取得
      - IndexBuilder.addDocuments() - ベクトルエントリを生成・挿入
      - バッチサイズ: 100件程度を推奨
    - **注意**: パース済みドキュメントはDBに永続化せず、バッチ単位でメモリ上で処理
    - **復旧方法**: エラー発生時は再度syncコマンドを実行することで復旧可能（全再構築方式のため、一貫した状態に戻る）
- **バックグラウンド実行方針**:
    - 初期実装: Webhookハンドラで即座にHTTP 200を返却後、`Promise`で非同期実行
    - Webhookタイムアウト（30秒）への対応として、処理開始前に返信（Reply）を完了させる
    - 処理完了後のPush通知は別途実行され、失敗してもインデックス更新は完了する
    - 将来のスケーラブル実装: ジョブキュー（BullMQ等）への移行を検討可能
- **インデックス再構築方針**:
    - 方式: 全削除→バッチ単位で挿入
    - 理由: メモリ効率と一貫性のバランス。外部APIから削除されたドキュメントも確実に削除される
    - 実装: `clearIndex()` → 複数回の `addDocuments()` で段階的にインデックス構築
    - バッチサイズ: 100件程度を推奨（メモリ使用量とAPI効率のバランス）
    - エラー時の動作: 部分的にインデックスが構築された状態になる可能性あり。再度syncで復旧可能
    - 将来の最適化: 差分更新方式（変更されたドキュメントのみ更新）への移行を検討可能

## 2. 質問応答ユースケース

### UC-QA-001: 質問に回答する

- **概要**: ユーザーの質問に対してRAGを使用して回答を生成する
- **アクター**: ユーザー（質問メッセージ経由）
- **事前条件**: なし
- **事後条件**: ユーザーに回答が返信される
- **主要フロー**:
    1. インデックスの存在を確認する
    2. RAGでインデックスを検索し、関連ドキュメントを取得する
    3. 取得したドキュメントと質問をもとにLLMで回答を生成する
    4. MessageSender.reply()で回答を送信する（動的コンテンツ）
- **代替フロー**:
    - インデックス未構築: UserNotifier.notifyIndexNotBuilt()で同期を促す通知をする（定型）
    - 関連ドキュメントなし: UserNotifier.notifyNoRelevantDocuments()で通知する（定型）
    - RAG検索エラー: エラーメッセージを返信する
    - LLM回答生成エラー: エラーメッセージを返信する
- **関連シナリオ**: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6
- **関連要件**: FR-QA-001〜007, FR-INDEX-003, NFR-ERR-003, NFR-ERR-004

## 3. インデックス状態確認ユースケース

### UC-STATUS-001: インデックス状態を確認する

- **概要**: インデックスが利用可能かどうかを確認する
- **アクター**: ユーザー（statusコマンド経由）
- **事前条件**: なし
- **事後条件**: ユーザーにインデックスの状態が返信される
- **主要フロー**:
    1. インデックスのステータス情報を取得する
    2. UserNotifier.notifyStatus()でステータスを通知する
- **代替フロー**:
    - インデックス未構築: notifyStatus()で未構築状態を通知し、syncコマンドを促す
    - ステータス取得エラー: エラーメッセージを返信する
- **関連シナリオ**: 1.7, 1.8
- **関連要件**: FR-STATUS-001, FR-STATUS-002, FR-STATUS-003, FR-INDEX-003, NFR-ERR-001

## 4. ユースケース関連図

```
┌─────────────────────────────────────────────────────────────┐
│                      LINE Messaging API                       │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  プレゼンテーション層    │
                 │  (Webhook Handler)     │
                 │  - 署名検証            │
                 │  - イベント解析         │
                 │  - コマンド/質問判定    │
                 └────────────┬───────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
        ▼                     ▼                     ▼
┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│  UC-SYNC-001     │ │  UC-QA-001       │ │  UC-STATUS-001   │
│  ドキュメントを   │ │  質問に回答する   │ │  インデックス状態 │
│  同期する        │ │                  │ │  を確認する       │
└────────┬─────────┘ └────────┬─────────┘ └────────┬─────────┘
         │                    │                    │
         │    ┌───────────────┴────────────────┐   │
         └───►│        UserNotifier            │◄──┘
              │       (ユーザー通知)            │
              └────────────────────────────────┘
```

## 5. ユースケースと使用ドメイン

各ユースケースは複数のドメインを横断してオーケストレーションを行う。

| ユースケース | 使用ドメイン |
|------------|------------|
| UC-SYNC-001 | Document, VectorIndex, Message |
| UC-QA-001 | VectorIndex, Message |
| UC-STATUS-001 | Document, VectorIndex, Message |

## 6. ユースケースが使用するポート

### UC-SYNC-001: ドキュメントを同期する

- `DocumentSource`: ドキュメントの順次取得（取得・パースを内包）
- `IndexBuilder`: インデックス構築
  - `clearIndex()`: 既存インデックスの削除
  - `addDocuments()`: バッチ単位でのドキュメント追加（チャンク分割、埋め込み生成、ベクトルストア操作を内包）
- `UserNotifier`: ユーザー通知
  - `notifySyncStarting()`: 同期開始通知
  - `notifySyncCompleted()`: 同期完了通知
  - `notifyNoDocumentsFound()`: ドキュメントなし通知
  - `notifySyncError()`: エラー通知

### UC-QA-001: 質問に回答する

- `QueryEngine`: インデックス検索と回答生成（埋め込み生成、類似検索、LLM回答生成を内包）
- `MessageSender`: 動的コンテンツ送信
  - `reply()`: LLMの回答を送信
- `UserNotifier`: 定型通知
  - `notifyIndexNotBuilt()`: インデックス未構築通知
  - `notifyNoRelevantDocuments()`: 関連ドキュメントなし通知

### UC-STATUS-001: インデックス状態を確認する

- `IndexBuilder`: インデックスステータス取得（エントリ数、最終更新日時等）
- `UserNotifier`: ユーザー通知
  - `notifyStatus()`: ステータス通知

## 7. プレゼンテーション層の責務

以下はユースケースではなく、プレゼンテーション層で処理する。単一責任の原則に従い、責務ごとに分離する。

### 責務の分離

#### ミドルウェア

- **署名検証**: LINE Webhookリクエストの署名を検証（FR-LINE-002, NFR-SEC-001）
  - 実装: `src/api/middlewares/lineSignatureVerifier.ts`
  - 不正な署名の場合は401を返却

#### イベントパーサー

専用のパーサークラスでWebhookイベントを解析する。

- **WebhookEventParser**: Webhookイベントの解析・変換
  - 実装: `src/api/parsers/webhookEventParser.ts`
  - メッセージイベントの抽出
  - イベントタイプの判定

- **CommandParser**: コマンド識別
  - 実装: `src/api/parsers/commandParser.ts`
  - syncコマンドの識別
  - statusコマンドの識別
  - 質問メッセージの識別

#### ルーター/コントローラー

ルーターはパーサーの結果を受け取り、適切なユースケースを呼び出すのみ。

- **Webhookルーター**: ユースケース呼び出し
  - 実装: `src/api/routes/webhook.ts`
  - パーサー結果に基づくユースケース振り分け
  - HTTPレスポンスの返却

### 処理フロー

```
┌─────────────────┐
│ HTTPリクエスト    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 署名検証         │ ← ミドルウェア
│ (Middleware)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ イベント解析      │ ← パーサー
│ (EventParser)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ コマンド判定      │ ← パーサー
│ (CommandParser) │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ ユースケース呼び出し│ ← ルーター
│ (Router)        │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ HTTPレスポンス    │
└─────────────────┘
```

### 設計意図

- **単一責任の原則**: 各クラスは1つの責務のみを持つ
- **テスト容易性**: パーサーを分離することで単体テストが容易になる
- **再利用性**: パーサーロジックを他のエンドポイントでも再利用可能
